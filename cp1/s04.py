from pcint import pcint, modularlambda
from numpy import trace
from itertools import izip
from math import floor

import contourgen

# Convention: L = lambda = 4-punctured sphere cross ratio parameter
#             C = quadratic differential parameter
#
# Together pairs (L,C) parameterize all CP^1 structures of bounded
# type on the four punctured sphere S_04.


# This class will compute holonomy for a given L and any number of
# values of C.  (Use this if L will be fixed for many calls, to avoid
# recomputing trajectories each time.)

class HolonomyException(Exception):
    pass

class S04(object):
    '''Represents the space of CP1 structures on the Riemann sphere punctured at 0, 1, L, infinity.'''
    def __init__(self,L=0.5,step=0.02,tol=0.000001,maxstep=5000, contours=3, fund_domain_contours=False):
        '''Initialize projective connection and ODE solver parameters,
        L = lambda = Riemann surface, C = quadratic differential.'''
        self._pcint = pcint(atol=tol, rtol=0.0, maxstep=maxstep, initstep=step)

        self.L = L
        self.fd = fund_domain_contours

        # Integration contours generated by functions in the contourgen module
        if fund_domain_contours:
            self.contours = contourgen.advanced(self.L,contours)
        else:
            self.contours = contourgen.simple(self.L,contours)

    def pl_hol(self,vertlist,C,close=False):
        '''Compute holonomy of a piecewise linear path specified a list of vertices'''
        if close:
            vertlist.append(vertlist[0])
        m = [[1.0+0j,0.0j],[0.0j,1.0+0j]]
        for p0,p1 in izip(vertlist[:-1],vertlist[1:]):
            m = self._pcint.seg_int(self.L,C,p0,p1,init=m)
            if m is None:
                raise HolonomyException('Integration failed, p0=%s, p1=%s, L=%s, C=%s, fd=%s' % (p0,p1,self.L,C,self.fd))
        return m

    def gens(self,C):
        '''Compute matrix generators for the holonomy group'''
        # This function is hard to test; generators are not canonical.
        return [ self.pl_hol(gamma,C,close=True) for gamma in self.contours ]

    def traces(self,C):
        '''Compute traces of holonomy group generators'''
        return [ trace(m) for m in self.gens(C) ]

# Convenience function to compute trace tuple directly from L and C
# (use this when L and C will change independently between calls)
def s04_lambda_hol(L=0.5,C=0.5,**kwargs):
    '''Compute traces of holonomy group generators for (L,C) projective connection; passes kwargs to S04.__init__()'''
    h = S04(L,**kwargs)
    return h.traces(C)

# We use this labeling for the elements of the symmetric group
#
# S_3 = PSL_2(Z/2)
#
# Label:   0     1     2     3     4     5
#
# Matrix:  1 0   1 1   0 1   0 1   1 1   1 0
#          0 1   0 1   1 0   1 1   1 0   1 1

# The left regular representation as permutations of these labels,
# in terms of generators T = element #1, and S = element #2
_shift_T = (1,0,4,5,2,3)
_shift_S = (2,3,0,1,5,4)

# S_3 acts on the bundle of affine spaces of quadratic differentials
# with second-order poles of fixed residue.  The expression 
#
# phi(L,C) = 1/(2 * z^2 * (z-1)^2) + 1/(2 * (z-L)^2) + C/(z*(z-1)*(z-L))
#
# represents a global trivialization of this bundle, so S_3 now acts
# on the fiber {C}.  We record the actions of the individual elements:
_affine_repar = ( lambda L,C: C,
                 lambda L,C: (1-L)*C-L,
                 lambda L,C: -C,
                 lambda L,C: -L*C+(1-L),
                 lambda L,C: (L-1)*C-L,
                 lambda L,C: L*C+(1-L),
                 )

_FD_EPSILON = 1e-12
_TAU_MAX_TRANSFORMATIONS = 100

# Is tau outside the standard fundamental domain of PSL_2(Z)?
def _outside_FD(tau):
    return (abs(tau) < (1.0 - _FD_EPSILON)) or (tau.real < (-0.5 - _FD_EPSILON)) or (tau.real > (0.5 + _FD_EPSILON))

def s04_tau_hol(tau=1.0j,C=0.0,**kwargs):
    # tau must be in upper half
    if tau.imag <= 0.0:
        raise HolonomyException('Invalid tau=%s, must be in upper half plane.' % tau)

    # First move tau into FD
    # Record the transformations used along the way
    # And the "residue", i.e. associated element of PSL_2(Z/2).
    transformations = []
    residue = 0
    N = 0
    while _outside_FD(tau):
        if (abs(tau) < (1.0 - _FD_EPSILON)):
            tau = -1.0/tau
            transformations.append(0)
            residue = _shift_S[residue]
        if (tau.real < (-0.5 - _FD_EPSILON)) or (tau.real > (0.5 + _FD_EPSILON)):
            k = int(floor(tau.real + 0.5))
            tau = tau - k
            transformations.append(k)
            if k % 2 != 0:
                residue = _shift_T[residue]
        N += 1
        if N > _TAU_MAX_TRANSFORMATIONS:
            raise HolonomyException('Unable to move tau into fundamental domain; exceeded %d transformations.' % _TAU_MAX_TRANSFORMATIONS)

    #print 'residue = ',residue
    #print 'transformations = %s\n' % str(transformations)

    # Now project to the lambda plane, the location of the fourth
    # puncture
    L = modularlambda(tau)
    # And transform the projective connection accordingly
    C = _affine_repar[residue](L,C)

    # Calculate holonomy of this transformed connection, reflecting if
    # necessary
    if L.imag < 0:
        L = L.conjugate()
        C = C.conjugate()
        x,y,z = s04_lambda_hol(L,C,fund_domain_contours=True,**kwargs)
        z = 8 - x*y - z
        x,y,z = x.conjugate(), y.conjugate(), z.conjugate()
    else:
        x,y,z = s04_lambda_hol(L,C,fund_domain_contours=True,**kwargs)

    # Now undo all of the transformations by acting on the resulting
    # trace triple by elements of the braid group.
    for a in reversed(transformations):
        if a == 0:
            x,y,z = y,x,8-x*y-z
        elif a > 0:
            for i in xrange(a):
                x,y,z = x,8-x*y-z,y
        else:
            for i in xrange(-a):
                x,y,z = x,z,8-x*z-y
    # Done.
    return x,y,z

